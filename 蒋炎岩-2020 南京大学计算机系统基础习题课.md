

# C 语言拾遗 (1): 机制

## 1.进入 C 语言之前：预编译

### 1.安装虚拟机

```bash
# 1.打开window cmd窗口，运行 命令 ,即可初始化一个centos系统
#Vagrant init centos/7    官方的太慢了，更改为中科大的源
vagrant init centos7 https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box
# 1.登录虚拟机
Vagrant ssh
# 2.切换root用户
su root
# 3.修改权限
[root@k8s-node1 vagrant]# vi /etc/ssh/sshd_config
#PermitRootLogin yes 
PasswordAuthentication yes
# 4.重启虚拟机
[root@k8s-node1 vagrant]# service sshd restart
Redirecting to /bin/systemctl restart sshd.servic
# 5.退出
[root@k8s-node1 vagrant]# exit
exit
[vagrant@k8s-node1 ~]$ exit
logout
Connection to 127.0.0.1 closed

# 6.固定虚拟机ip  修改 Vagrantfile
config.vm.network "private_network", ip: "192.168.56.10"
```

安装一些工具

```bash
yum -y install gcc   #安装最新的gcc
yum install vim
yum -y install gcc gcc-c++
yum install -y libstdc++-static  
yum install -y glibc-static   #链接需要的依赖库
```



### 2.进入 C 语言之前：预编译

`#include <>` 指令

以下代码有什么区别？

```
#include <stdio.h>
#include "stdio.h"
```

------

一个是从本地目录优先加载，一个是直接从库加载

为什么在没有安装库时会发生错误？

```
#include <SDL2/SDL2.h>
```

------

你可能在书/阅读材料上了解过一些相关的知识

- 但更好的办法是阅读命令的日志
- `gcc --verbose a.c`

### 3.有趣的预编译

以下代码会输出什么？

- 为什么？

```c
#include <stdio.h>
int main() {
#if aa == bb
  printf("Yes\n");
#else
  printf("No\n");
#endif
}
```

`gcc --verbose a.c`

```bash
[root@localhost l1]# gcc --verbose a.c
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapper
Target: x86_64-redhat-linux
Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux
Thread model: posix
gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -quiet -v a.c -quiet -dumpbase a.c -mtune=generic -march=x86-64 -auxbase a -version -o /tmp/cce2ItfI.s
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-44) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-44), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=63 --param ggc-min-heapsize=62335
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
 /usr/local/include
 /usr/include
End of search list.
GNU C (GCC) version 4.8.5 20150623 (Red Hat 4.8.5-44) (x86_64-redhat-linux)
	compiled by GNU C version 4.8.5 20150623 (Red Hat 4.8.5-44), GMP version 6.0.0, MPFR version 3.1.1, MPC version 1.0.1
GGC heuristics: --param ggc-min-expand=63 --param ggc-min-heapsize=62335
Compiler executable checksum: 231b3394950636dbfe0428e88716bc73
COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccF1q9kr.o /tmp/cce2ItfI.s
GNU assembler version 2.27 (x86_64-redhat-linux) using BFD version version 2.27-43.base.el7
COMPILER_PATH=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/:/usr/libexec/gcc/x86_64-redhat-linux/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/
LIBRARY_PATH=/usr/lib/gcc/x86_64-redhat-linux/4.8.5/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/:/lib/../lib64/:/usr/lib/../lib64/:/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
 /usr/libexec/gcc/x86_64-redhat-linux/4.8.5/collect2 --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../.. /tmp/ccF1q9kr.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/4.8.5/crtend.o /usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../lib64/crtn.o
 # 编译后 多了一个 a.out 文件
[root@localhost l1]# ls
a.c  a.out
# 运行
[root@localhost l1]# ./a.out 
Yes
```

原因：

aa 和 bb 都未被定义，所以 aa==bb 相当于 null == null  结果为 true

### 4.宏定义与展开

#### 宏展开：通过复制/粘贴改变代码的形态

- `#include` → 粘贴文件
- `aa`, `bb` → 粘贴符号

知乎问题：如何搞垮一个 OJ？

```bash
#define A "aaaaaaaaaa"
#define TEN(A) A A A A A A A A A A
#define B TEN(A)
#define C TEN(B)
#define D TEN(C)
#define E TEN(D)
#define F TEN(E)
#define G TEN(F)
int main() { puts(G); }
```

```bash
gcc b.c
[root@localhost l1]# ls
a.out  b.c
[root@localhost l1]# ./a.out
aaa...
...
# 长度 
[root@localhost l1]# ./a.out | wc
      1       1 10000001

# 大小
[root@localhost l1]# ll
total 9780
-rwxr-xr-x. 1 root root 10006688 Aug 16 14:09 a.out
-rw-r--r--. 1 root root      184 Aug 16 14:09 b.c
```

### 如何躲过 Online Judge 的关键字过滤？

```c
#define SYSTEM sys ## tem

[root@localhost l1]# vim a.c
 
#define A sys ## tem
int main(){
	A("echo hello");
}

[root@localhost l1]# gcc a.c
[root@localhost l1]# ./a.out 
hello
```

------

### 如何毁掉一个身边的同学？

> #define true (__LINE__ % 2 != 0)

```
#define true (__LINE__ % 2 != 0)
#include <stdio.h>
int main(){
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
        if(true) printf("yes %d\n",__LINE__);
}
```

隔行打印

```bash
[root@localhost l1]# gcc a.c
[root@localhost l1]# ./a.out 
yes 9
yes 11
yes 13
yes 15
yes 17
```

```c
#define s (((((((((((((((( 0
#define _ * 2)
#define X * 2 + 1)
static unsigned short stopwatch[] = {
  s _ _ _ _ _ X X X X X _ _ _ X X _ ,
  s _ _ _ X X X X X X X X X _ X X X ,
  s _ _ X X X _ _ _ _ _ X X X _ X X ,
  s _ X X _ _ _ _ _ _ _ _ _ X X _ _ ,
  s X X _ _ _ _ _ _ _ _ _ _ _ X X _ ,
  s X X _ X X X X X _ _ _ _ _ X X _ ,
  s X X _ _ _ _ _ X _ _ _ _ _ X X _ ,
  s X X _ _ _ _ _ X _ _ _ _ _ X X _ ,
  s _ X X _ _ _ _ X _ _ _ _ X X _ _ ,
  s _ _ X X X _ _ _ _ _ X X X _ _ _ ,
  s _ _ _ X X X X X X X X X _ _ _ _ ,
  s _ _ _ _ _ X X X X X _ _ _ _ _ _ , };
```

```bash
[root@localhost l1]# gcc -E d.c 
static unsigned short stopwatch[] = {
  (((((((((((((((( 0 * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) ,
  (((((((((((((((( 0 * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2 + 1) * 2 + 1) * 2 + 1) ,
  (((((((((((((((( 0 * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2 + 1) * 2 + 1) ,
  (((((((((((((((( 0 * 2) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) * 2) ,
  (((((((((((((((( 0 * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) ,
  (((((((((((((((( 0 * 2 + 1) * 2 + 1) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) ,
  (((((((((((((((( 0 * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) ,
  (((((((((((((((( 0 * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) ,
  (((((((((((((((( 0 * 2) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2 + 1) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2) * 2) ,
  (((((((((((((((( 0 * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) ,
  (((((((((((((((( 0 * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) ,
  (((((((((((((((( 0 * 2) * 2) * 2) * 2) * 2) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2 + 1) * 2) * 2) * 2) * 2) * 2) * 2) };

```

### 5.Macros

宏展开：通过复制/粘贴改变代码的形态

- 反复粘贴，直到没有宏可以展开为止

------

例子：X-macro

```
#define NAMES(X) \
  X(Tom) X(Jerry) X(Tyke) X(Spike)

int main() {
  #define PRINT(x) puts("Hello, " #x "!");
  NAMES(PRINT)
  
  #define PRINT(x) puts("GoodBye, " #x "!");
  NAMES(PRINT)
}
```

```bash
[root@localhost l1]# ./a.out 
Hello, Tom!
Hello, Jerry!
Hello, Tyke!
Hello, Spike!
GoodBye, Tom!
GoodBye, Jerry!
GoodBye, Tyke!
GoodBye, Spike!
```

### 6.有趣的预编译

发生在实际编译之前

- 也称为元编程 (meta-programming)
  - gcc 的预处理器同样可以处理汇编代码
  - C++ 中的模板元编程; Rust 的 macros; ...

------

Pros

- 提供灵活的用法 (X-macros)
- 接近自然语言的写法

Cons

- 破坏可读性 [IOCCC](https://www.ioccc.org/)、程序分析 (补全)、……

```
#define L (
int main L ) { puts L "Hello, World" ); }
```

## 2.编译与链接

### 1.编译

一个不带优化的简易 (理想) 编译器

- C 代码的连续一段

  总能找到对应的

  一段**连续**的机器指令

  - 这就是为什么大家会觉得 C 是高级的汇编语言！

------

```c
int foo(int n) {
  int sum = 0;
  for (int i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}
```

```bash
# 直接进行编译会报错   -S 只激活预处理和编译，就是指把文件编译成为汇编代码。
[root@localhost l1]# gcc -S f.c 
f.c: In function ‘foo’:
f.c:3:3: error: ‘for’ loop initial declarations are only allowed in C99 mode
   for (int i = 1; i <= n; i++) {
   ^
f.c:3:3: note: use option -std=c99 or -std=gnu99 to compile your code
[root@localhost l1]# gcc -std=c99 -S f.c
[root@localhost l1]# ls
 f.c  f.s
[root@localhost l1]# cat f.s
	.file	"f.c"
	.text
	.globl	foo
	.type	foo, @function
foo:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)
	movl	$0, -4(%rbp)
	movl	$1, -8(%rbp)
	jmp	.L2
.L3:
	movl	-8(%rbp), %eax
	addl	%eax, -4(%rbp)
	addl	$1, -8(%rbp)
.L2:
	movl	-8(%rbp), %eax
	cmpl	-20(%rbp), %eax
	jle	.L3
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	foo, .-foo
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
	.section	.note.GNU-stack,"",@progbits
[root@localhost l1]# 
```

gcc -c  进行编译，查看  foo累加函数的机器码

```bash
[root@localhost l1]# gcc -c -std=c99 f.c
[root@localhost l1]# objdump -d f.o
f.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <foo>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	89 7d ec             	mov    %edi,-0x14(%rbp)
   7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
   e:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
  15:	eb 0a                	jmp    21 <foo+0x21>
  17:	8b 45 f8             	mov    -0x8(%rbp),%eax
  1a:	01 45 fc             	add    %eax,-0x4(%rbp)
  1d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  21:	8b 45 f8             	mov    -0x8(%rbp),%eax
  24:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  27:	7e ee                	jle    17 <foo+0x17>
  29:	8b 45 fc             	mov    -0x4(%rbp),%eax
  2c:	5d                   	pop    %rbp
  2d:	c3                   	retq   
[root@localhost l1]# 
```

### 2.链接

将多个二进制目标代码拼接在一起

- C 中称为编译单元 (compilation unit)
- 甚至可以链接 C++, [rust](https://rust-embedded.github.io/book/interoperability/rust-with-c.html), ... 代码

**链接两个c文件**

```bash
# 1.编写 main函数
[root@localhost l1]# cat b.c
int foo(int);
int main(){
   printf("%d\n",foo(100));
}

# 2.编译 main
[root@localhost l1]# gcc -c b.c
[root@localhost l1]# objdump -d b.o

b.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 <main>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	bf 64 00 00 00       	mov    $0x64,%edi
   9:	e8 00 00 00 00       	callq  e <main+0xe>
   e:	89 c6                	mov    %eax,%esi
  10:	bf 00 00 00 00       	mov    $0x0,%edi
  15:	b8 00 00 00 00       	mov    $0x0,%eax
  1a:	e8 00 00 00 00       	callq  1f <main+0x1f>
  1f:	5d                   	pop    %rbp
  20:	c3                   	retq   
```

```bash
# 1.将两个编译后的文件进行链接
[root@localhost l1]# gcc f.o b.o -static
/usr/bin/ld: cannot find -lc
collect2: error: ld returned 1 exit status

# 2.找不到 libc.so库   经查 在 lib64文件夹下有，进行链接到lib文件夹下也无法解决问题
# 3.解决方法 如下
yum install -y glibc-static

# 4.再次运行，大功告成
[root@localhost l1]# gcc f.o b.o -static
[root@localhost l1]# ls
a.c  a.out  b.c  b.o  d.c  e.c  f.c  f.o  f.s
[root@localhost l1]# ./a.out 
5050

```

链接c++文件

```bash
extern "C" {
  int foo() { return 0; }
}
int bar() { return 0; }
```



```bash
[root@localhost l1]# vim a.cc
# 上面的文件
[root@localhost l1]# g++ -c a.cc
[root@localhost l1]# objdump -d a.o | less
a.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 <foo>:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   b8 00 00 00 00          mov    $0x0,%eax
   9:   5d                      pop    %rbp
   a:   c3                      retq   

000000000000000b <_Z3barv>:
   b:   55                      push   %rbp
   c:   48 89 e5                mov    %rsp,%rbp
   f:   b8 00 00 00 00          mov    $0x0,%eax
  14:   5d                      pop    %rbp
  15:   c3                      retq   
(END)
```

## 3.加载：进入 C 语言的世界

### C 程序执行的两个视角

静态：C 代码的连续一段总能对应到一段连续的机器指令

动态：C 代码执行的状态总能对应到机器的状态

- 源代码视角
  - 函数、变量、指针……
- 机器指令视角
  - 寄存器、内存、地址……

------

两个视角的共同之处：内存

- 代码、变量 (源代码视角) = 地址 + 长度 (机器指令视角)
- (不太严谨地) 内存 = 代码 + 数据 + 堆栈
  - 因此理解 C 程序执行最重要的就是内存模型

```bash
[root@localhost l1]# vi a.c
int main(){
  int *p = (void *)0;
  *p = 1;
}
...                                                                                                      
:!gcc % && ./a.out
/bin/bash: line 1: 15098 Segmentation fault      ./a.out
shell returned 139
```



#### 从 `main` 函数开始执行

标准规定 C 程序从 `main` 开始执行

- (思考题：谁调用的 `main`？进程执行的第一条指令是什么？)

------

```
int main(int argc, char *argv[]);
```

- argc (argument count): 参数个数
- argv (argument vector): 参数列表 (NULL结束)

------

上次课已经演示过

`ls -al` (`argc = 2, argv = ["ls", "-al", NULL]`)

#### `main`, `argc` 和 `argv`

一切皆可取地址！

```
void printptr(void *p) {
  printf("p = %p;  *p = %016lx\n", p, *(long *)p);
}
int x;
int main(int argc, char *argv[]) {
  printptr(main);  // 代码
  printptr(&main);
  printptr(&x);    // 数据
  printptr(&argc); // 堆栈
  printptr(argv);
  printptr(&argv);
  printptr(argv[0]);
}
```

```bash
p = 0x400558;  *p = 10ec8348e5894855
p = 0x400558;  *p = 10ec8348e5894855
p = 0x601038;  *p = 0000000000000000
p = 0x7ffcfb59bafc;  *p = 0000000000000001
p = 0x7ffcfb59bbe8;  *p = 00007ffcfb59d80d
p = 0x7ffcfb59baf0;  *p = 00007ffcfb59bbe8
p = 0x7ffcfb59d80d;  *p = 0074756f2e612f2e

shell returned 43

Press ENTER or type command to continue
[root@localhost note]# cat a.c
void printptr(void *p) {
  printf("p = %p;  *p = %016lx\n", p, *(long *)p);
}
int x;
int main(int argc, char *argv[]) {
  printptr(main);  // 代码
  printptr(&main);
  printptr(&x);    // 数据
  printptr(&argc); // 堆栈
  printptr(argv);
  printptr(&argv);
  printptr(argv[0]);
}
```



## C Type System

类型：对一段内存的解读方式

- 非常 “汇编”——没有 class, polymorphism, type traits, ...
- C 里所有的数据都可以理解成是地址 (指针) + 类型 (对地址的解读)

------

例子 (是不是感到学了假的 C 语言)

```
#include<stdio.h>
#include<assert.h>
int main(int argc, char *argv[]) {
  int (*f)(int, char *[]) = main;
  if (argc != 0) {
    char ***a = &argv, *first = argv[0], ch = argv[0][0];
    printf("arg = \"%s\";  ch = '%c'\n", first, ch);
    assert(***a == ch);
    f(argc - 1, argv + 1);
  }
}
```

```bash
[root@localhost note]# vi b.c
[root@localhost note]# gcc b.c
[root@localhost note]# ./a.out 
arg = "./a.out";  ch = '.'
[root@localhost note]# ./a.out 1 2 3 4 hello
arg = "./a.out";  ch = '.'
arg = "1";  ch = '1'
arg = "2";  ch = '2'
arg = "3";  ch = '3'
arg = "4";  ch = '4'
arg = "hello";  ch = 'h'
[root@localhost note]# 
```

# End.

- C 语言简单 (在可控时间成本里可以精通)
- C 语言通用 (大量系统是用 C 语言编写的)
- C 语言实现对底层机器的精确控制 ([鸿蒙](https://openharmony.gitee.com/openharmony))
- 推荐阅读：[The Art of Readable Code](https://www.oreilly.com/library/view/the-art-of/9781449318482/)